from core.plugin_interface import PluginInterface
import os
import subprocess
import json
import sys  # Import sys to dynamically get the Python interpreter
from datetime import datetime

class SubdomainPlugin(PluginInterface):
    def __init__(self):
        pass

    def run(self, data):
        domain = data.get("domain", "")
        if domain:
            try:
                # Define the current date for file naming
                current_date = datetime.now().strftime("%Y-%m-%d")

                # Get the current Python interpreter dynamically
                python_interpreter = sys.executable

                # Subhunt tool directory and output file paths
                subhunt_dir = os.path.join(os.getcwd(), "tools", "Subhunt", "main.py")
                output_file_txt = f"subenum-{domain}-{current_date}.txt"
                output_dir = os.path.join(os.getcwd(), "tools", "Subhunt", "output")
                output_file_txt_path = os.path.join(output_dir, output_file_txt)  # Use output directory

                # Ensure the output directory exists
                if not os.path.exists(output_dir):
                    os.makedirs(output_dir)

                # Ensure Subhunt script exists
                if not os.path.exists(subhunt_dir):
                    return f"Error: Subhunt tool not found at {subhunt_dir}"

                # Command to run Subhunt using the dynamically detected Python interpreter
                command = [python_interpreter, subhunt_dir, "-d", domain]

                # Use subprocess to run the command
                result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

                if result.returncode != 0:
                    return f"Error running Subhunt tool: {result.stderr}"

                # Check if the output file was created
                if not os.path.exists(output_file_txt_path):
                    return f"Error: {output_file_txt_path} not found."

                # Parse the generated .txt file to extract subdomains
                subdomains = self.read_subhunt_output(output_file_txt_path)

                # Save subdomains to JSON file (overwrite previous entry if exists)
                output_file_json = os.path.join(os.getcwd(), "outputs", "subdomain_output.json")
                self.save_subdomains_to_json(output_file_json, domain, subdomains, current_date)

                return f"Subdomains for {domain} saved: {subdomains}"
            except Exception as e:
                return f"Error: {str(e)}"
        else:
            return "Error: No domain provided for subdomain discovery."

    def read_subhunt_output(self, file_path):
        """
        Reads the output file generated by Subhunt and extracts subdomains.
        """
        subdomains = []
        try:
            with open(file_path, 'r') as file:
                for line in file:
                    line = line.strip()
                    if line:  # Assuming each line contains a subdomain
                        subdomains.append(line)
        except FileNotFoundError:
            return f"Error: {file_path} not found."
        return subdomains

    def save_subdomains_to_json(self, json_file_path, domain, subdomains, current_date):
        """
        Save the subdomains to the JSON file, overwriting the entry for the domain if it exists.
        """
        # Load the existing data from the JSON file, or initialize an empty list
        if os.path.exists(json_file_path):
            with open(json_file_path, "r") as f:
                data = json.load(f)
        else:
            data = []

        # Create the new entry for the domain
        new_entry = {
            "time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "plugin": "SubdomainPlugin",
            "domain": domain,
            "subdomains": subdomains
        }

        # Update the entry for the domain (overwrite if exists)
        domain_updated = False
        for i, entry in enumerate(data):
            if entry["domain"] == domain:
                data[i] = new_entry  # Overwrite the entry
                domain_updated = True
                break

        # If the domain doesn't exist in the JSON, append it as a new entry
        if not domain_updated:
            data.append(new_entry)

        # Write the updated data back to the JSON file
        with open(json_file_path, "w") as f:
            json.dump(data, f, indent=4)

    def terminate(self):
        print("Subdomain Plugin Terminated.")
